use std::cmp::max;
use std::fs::File;
use std::io::{self, BufReader, BufRead};
use std::env;

fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();
    let input = &args[1];

    let problem = read_input(input)?;
    solve1(&problem);
    solve2(&problem);

    Ok(())
}

fn solve1(problem: &Problem) {
    let res =
        problem.secret_numbers.iter()
                              .map(|secret| {
                                let mut secret = *secret;
                                for _ in 0..2000 {
                                    secret = secret_to_secret(secret);
                                }
                                secret
                              }).sum::<i64>();
    println!("What is the sum of the 2000th secret number generated by each buyer? {}", res);

}

fn solve2(problem: &Problem) {

    let secrets = generate_secrets(problem);

    let price_difference = generate_price_differences(&secrets);


    let res = generate_combinations().map(|sequence| {
        apply_sequence_to_problem(&sequence,
                                  &secrets,
                                  &price_difference)
    }).max().unwrap();
    println!("What is the most bananas you can get? {}", res);
}

fn generate_combinations() -> impl Iterator<Item = [i64; 4]> {
    (-9..=9)
        .flat_map(|a| {
            (-9..=9).flat_map(move |b| {
                (-9..=9).flat_map(move |c| {
                    (-9..=9).map(move |d| [a, b, c, d])
                })
            })
        })
}

fn generate_price_differences(secrets: &Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut res = Vec::new();

    for secret in secrets {
        let last_numbers =
            secret.iter()
                  .map(|secret|secret_to_price(*secret))
                  .collect::<Vec<i64>>();

        let differences: Vec<i64> =
            last_numbers.iter().zip(last_numbers.iter().skip(1)).map(|(a, b)| b - a).collect();

        res.push(differences)
    }

    res
}

fn generate_secrets(problem: &Problem) -> Vec<Vec<i64>> {
    let mut res = Vec::new();
    for secret in &problem.secret_numbers {
        let mut secrets = Vec::new();
        secrets.push(*secret);

        let mut secret = *secret;
        for _ in 0..2000 {
            secret = secret_to_secret(secret);
            secrets.push(secret);
        }
        res.push(secrets);
    }

    res
}

fn secret_to_price(secret: i64) -> i64 {
    secret.to_string().chars().last().unwrap().to_string().parse::<i64>().unwrap()
}

fn apply_sequence_to_problem(sequence: &[i64; 4],
                             secrets: &Vec<Vec<i64>>,
                             price_difference: &Vec<Vec<i64>>) -> i64 {
    let mut res = 0_i64;
    for index in 0..secrets.len() {
        let monkey_secrets = &secrets[index];
        let monkey_price_differences = &price_difference[index];
        let monkey_res =
            apply_sequence_to_monkey(sequence,
                                     monkey_secrets,
                                     monkey_price_differences).unwrap_or(0);
        res += monkey_res;
    }
    res
}

fn apply_sequence_to_monkey(sequence: &[i64; 4],
                            monkey_secrets: &Vec<i64>,
                            monkey_price_differences: &Vec<i64>) -> Option<i64> {

    let index =
        monkey_price_differences.windows(sequence.len())
                        .enumerate()
                        .find(|(_, window)| *window == sequence)
                        .map(|(index, _)| index)? + sequence.len();


    Some(secret_to_price(monkey_secrets[index]))
}

fn secret_to_secret(secret_number: i64) -> i64 {
    let mut new_secret = secret_number;

    let multiplied_value = new_secret * 64;
    new_secret = mix_into(new_secret, multiplied_value);
    new_secret = prune(new_secret);

    let divided_value = new_secret / 32;
    new_secret = mix_into(new_secret, divided_value);
    new_secret = prune(new_secret);

    let multiplied_value = new_secret * 2048;
    new_secret = mix_into(new_secret, multiplied_value);
    new_secret = prune(new_secret);

    new_secret
}


fn mix_into(secret_number: i64, value: i64) -> i64 {
    secret_number ^ value
}

fn prune(secret_number: i64) -> i64 {
    secret_number % 16777216
}

struct Problem {
    secret_numbers: Vec<i64>,
}

impl Problem {
    fn new(secret_numbers: Vec<i64>) -> Self {
        Problem { secret_numbers }
    }
}

fn read_input(filename: &String) ->  io::Result<Problem> {
    let file_in = File::open(filename)?;
    Ok(Problem::new( BufReader::new(file_in).lines()
                                            .map(|x| x.unwrap().parse::<i64>().unwrap())
                                            .collect() ) )
}
